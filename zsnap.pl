#!/usr/bin/perl -w
#
# found it...
#
###############################################################################
###############################################################################
###############################################################################
#
# zsnap.pl - creates and split/checksum/concatenats/restores a zfs snapshot
#
# Written by Peter Wirdemo (peter <dot> wirdemp gmail <dot> com)
#
# Latest version can be found at github
# localhost# git clone https://github.com/pewo/zsnap.git
#
my($version) = "0.1.15";
#
# Trying to fix different pools problem
#
###############################################################################
#	Mon Sep 11 11:27:53 CEST 2017
# Version: 0.1.15 added info abot snapshots to be used for autoclean on remote
# Version: 0.1.14 some bugfixes in the around --clean=0
# Version: 0.1.13 added support for cleaning snapshots and impl. --force
# Version: 0.1.12 added machine created config file to be used in rdsnap
# Version: 0.1.11 added minor printouts when creating checksum files
# Version: 0.1.10 added support for rdsnap and mksnap tags in config file
# Version: 0.1.9 added support for syncfrom, i.e destory older snapshots
# Version: 0.1.8 added support for syncto, i.e destory newer snapshots
# Version: 0.1.7 extended the config file to include more things
# Version: 0.1.6 implemented to set the receiving fs to be readonly
# Version: 0.1.5 implemented compress/nocompress ( --compress )
###############################################################################
#    Date: Fri Oct 16 11:10:49 CEST 2015
# Version: 0.1.4 implemented wait between uploading to transfer directory
###############################################################################
#    Date: Mon Oct  5 12:43:25 CEST 2015
# Version: 0.1.3 changed "zfs" to "$zfscommand" which is def to /sbin/zfs
###############################################################################
#    Date: Sun Jun 14 01:13:15 CEST 2015
# Version: 0.1.2 Renamed to zsnap.pl
###############################################################################
#    Date: Sun Jun 14 01:13:15 CEST 2015
# Version: 0.1.1 Added support for filesystem lock between execution:
#	sub done($$)
#	sub done_name($$) {
#	sub create_done($$) {
###############################################################################
# Version: 0.1.0 Initial version
###############################################################################
#
########
# Usage: 
########
# % zsnap.pl <--mksnap|--rdsnap> --fs=<zfs filesystem> | --help --force
# % zsnap.pl --mksnap --fs=tank/mirror
#
# This will create the following files:
#
# <destdir>/tank.mirror.20150612104938.snap.comp.asc
# This file contains the sha256sum checksum for all the .part.NNNN files
#     ecb4a <snip> 7cdc40f4cbd *tank.mirror.20150612104938.snap.comp.part.0000
#
# <destdir>/tank.mirror.20150612104938.snap.comp.asc.asc
#  This file containes the sha256sum checksums for .snap.comp.asc
#   and .snap.com.asc.tot files
#     deb21 <snip> 8f6011a5d9 *tank.mirror.20150612104938.snap.comp.asc
#     4865d <snip> 57d7a4e22a *tank.mirror.20150612104938.snap.comp.asc.tot
#
# <destdir>/tank.mirror.20150612104938.snap.comp.asc.tot
# This file contains the sha256sum checksum for the compressd snapshot
#     4eca02bccd <snip> ecb425a4ea4cbd *tank.mirror.20150612104938.snap.comp
#
# <destdir>/tank.mirror.20150612104938.snap.comp.part.0000
# This/These files are the result of the split of the snapshot
#
# % zsnap.pl --rdsnap --fs=tank/mirror
#
# This will insert the snapshot (created above) into the filesystem
#
# --force will use the -F flag on zfs receive:
#
# From the man page:
#
# -F
#  Force a rollback of the file system to the most recent snapshot before
#  performing the receive operation. If receiving an incremental replication
#  stream (for example, one generated by zfs send -R -[iI]), destroy  snapshots
#  and  file  systems that do not exist on the sending side.
###############################################################################
###############################################################################
###############################################################################

use strict;
use Sys::Hostname;
use Data::Dumper;
use Getopt::Long;
use File::Copy;
use File::Basename;
use Fcntl qw(:flock SEEK_END); # import LOCK_* and SEEK_END constants

#
# Global parameters, maybe read from the config or cmdline
#
my($prog) = "$0";
#
# config
my($destdir) = undef;
my($transdir) = undef;
my($srcdir) = undef;
my($zfscommand) = "/sbin/zfs";
my($filecommand) = "/usr/bin/file";
my($lockdir) = "/tmp";
my($maxtransfer) = 2   * 1000 * 1000 * 1000; # 1 GB
my($splitbytes) =  512 * 1000 * 1000; # 512 MB
#
# cmdline
my $compress = 0;
my $verbose = 0;
my $force = undef;

##################################################
# mylock($lockfile)
# Creates a lock on $lockfile, or dies if it cant
# When used without parameter, remove the
# previoulsy used lockfile ($savename)
##################################################
{
	my($savename) = undef;

	sub mylock {
		my($lockfile) = shift;
		if ( $savename ) {
			close(LOCK);
			unlink($savename);
			return(0);
		}
		$lockfile =~ s/\W/_/g;
		$lockfile = $lockdir . "/." . $lockfile . ".lock";
		$savename = $lockfile;
		if ( open(LOCK,">>$savename") ) {
			my $rc = flock(LOCK, LOCK_EX|LOCK_NB);
			unless ( $rc ) {
				unlink($savename);
				print "Cannot create lock($savename,rc=$rc): $!\n";
			}
			return($rc);
		}
		else {
			return(0);
		}
		return(1);
	}
}


####################################
# readconf($fs)
# Import configuration parameters
####################################
sub readconf($) {
	my($conf) = shift;
	my(%hash) = ();
	return(%hash) unless ( $conf );
	if ( open(IN,"<$conf") ) {
		foreach ( <IN> ) {
			chomp;
			s/^\s+//;
			s/\s+$//;
			next if ( m/^#/ );
			my($key,$value) = split(/\s*=\s*/,$_);
			next unless ( $key );
			next unless ( defined($value) );
			$hash{lc($key)}=$value;
		}
	}
	return(%hash);
}

######################################
# check_conf*(name, value)
# Checks if tha value is within limits
######################################
sub check_conf_input($$) {
	my($name) = shift;
	if ( ! defined($name) ) {
		die "name parameter is not defined, exiting...\n";
	}
	my($value) = shift;
	if ( ! defined($value) ) {
		die "value parameter is not defined, exiting...\n";
	}
	return($name,$value);
}
	
sub check_conf_dec($$) {
	my($name,$value) = check_conf_input(shift,shift);
	unless ( $value =~ /^\d+$/ ) {
		die "The parameter [$name] is set to [$value], which is not a decimal value, exiting...\n";
	}
	return($value);
}
sub check_conf_dir($$) {
	my($name,$value) = check_conf_input(shift,shift);
	if ( ! -d $value ) {
		die "The parameter [$name] is set to [$value], which is not a directory, exiting...\n";
	}
	return($value);
}
sub check_conf_exec($$) {
	my($name,$value) = check_conf_input(shift,shift);
	if ( ! -x $value ) {
		die "The parameter [$name] is set to [$value], which is not an executable, exiting...\n";
	}
	return($value);
}

####################################
# done_name($fs)
# constructs file donefile name from 
# filesystem and transdir
####################################
sub done_name($$$) {
	my($dir) = shift;
	my($donefile) = shift;
	my($ext) = shift;
	$donefile =~ s/\W/./g;
	$donefile = $dir . "/" . $donefile . "." . $ext;
	return($donefile);
}

##########################################
# done($dir,$fs)
# Check if there is a donefile already
# I.e there are files waiting for transfer
##########################################
sub done($$$) {
	my($dir) = shift;
	my($donefile) = shift;
	my($ext) = shift;
	$donefile = done_name($dir,$donefile,$ext);
	if ( -f $donefile ) {
		return($donefile) 
	}
	else {
		return(undef);
	}
}

###########################################
# create_done($donefile,$fs,$ext,"message"))
# Create a donefile per filesystem, to stop
# createing of more snapshot until the prev
# files are removed
###########################################
sub create_done($$$;$) {
	my($dir) = shift;
	my($fs) = shift;
	my($ext) = shift;
	my($msg) = shift;
	my($donefile);
	$donefile = done_name($dir,$fs,$ext);
	unlink($donefile);
	if ( open(OUT,">>$donefile") ) {
		if ( $msg ) {
			chomp($msg);
			print OUT $msg . "\n";
		}
		else {
			print OUT scalar localtime(time) . "\n";
		}
		close(OUT);
	}
	return($donefile);
}

##########################################################
# timestamp()
# Returns a string of the current time as YYYYMMDDHHMMSS
##########################################################
sub timestamp() {
	 #  0    1    2     3     4    5     6     7     8
	my($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = gmtime(time);
	my($stamp) = sprintf("%4.4d%02.2d%02.2d%02.2d%02.2d%02.2d",
		$year+1900, $mon+1, $mday, $hour, $min, $sec);
	return($stamp);
}

##################################################################
# my_system(@args)
# A wrapper that runs system byt checks the extended return code
##################################################################
sub my_system {
	print "\ncmd=" . join(" ",@_) . "\n" if ( $verbose );
	my($rc) = system(@_);
	if ($rc == -1) {
		print "failed to execute: $!\n";
		return($rc);
	}
	elsif ($rc & 127) {
		die "child died with signal %d, %s coredump\n", ($rc & 127),  ($rc & 128) ? 'with' : 'without';
	}
	else {
		$rc = $rc >> 8;
		print "rc=$rc\n" if ( $verbose );
		return($rc);
	}
}

###########################################
# if_fs($fs)
# Return true or false depending on if the 
#  zfs filesystem exists on the system
###########################################
sub if_fs($) {
	my($fs) = shift;
	my($rc) =  my_system("$zfscommand list $fs");
	if ( $rc ) {
		return(0);
	}
	else {
		return(1);
	}
}

###############################################
# destroy_snapshot($fs)
# destroys the zfs snapshot $fs
###############################################
sub destroy_snapshot($) {
	my($fs) = shift;
	unless ( open(POPEN,"$zfscommand destroy $fs | ") ) {
		die "Unable to destroy $fs, exiting...\n" or exit(1);
	}
	my(@arr);
	foreach ( <POPEN> ) {
		print;
	}
	close(POPEN);
}

###############################################
# list_snapshot($fs)
# List all the snapshot in the filesystem($fs)
###############################################
sub list_snapshots($) {
	my($fs) = shift;
	unless ( open(POPEN,"$zfscommand list -t snapshot | ") ) {
		die "Unable to list snapshots, exiting...\n" or exit(1);
	}
	my(@arr);
	foreach ( <POPEN> ) {
		next unless ( m/(^$fs\@\d{14}.snap)\s+/ );
		push(@arr,$1);
	}
	close(POPEN);
	return(@arr);
}

###################################
# zfs_get($fs,$attr)
# Get the attr from the filesystem
###################################
sub zfs_get($$) {
	my($fs) = shift;
	my($attr) = shift;
	unless ( open(POPEN,"$zfscommand get -H -o value $attr $fs | ") ) {
		die "Unable to get attr($attr) from $fs exiting...\n" or exit(1);
	}
	my(@arr);
	foreach ( <POPEN> ) {
		next unless ( m/(^.*)$/ );
		push(@arr,$1);
	}
	close(POPEN);
	return(@arr);
}

###################################
# zfs_set($fs,$attr,$value)
# Set and attr to the filesystem
###################################
sub zfs_set($$$) {
	my($fs) = shift;
	my($attr) = shift;
	my($value) = shift;
	return unless ( defined($value) );
	foreach ( zfs_get($fs,$attr) ) {
		print "from $fs I got $attr=[$_]\n" if ( $verbose );
		unless ( $_ eq $value ) {
			print "Changing $attr=[$value]\n" if ( $verbose );
			unless ( open(POPEN,"$zfscommand set $attr=$value $fs | ") ) {
				die "Unable to get attr($attr) from $fs exiting...\n" or exit(1);
			}
			foreach ( <POPEN> ) {
				print;
			}
			close(POPEN);
		}
	}
}

###########################################################
# first_snapshot($fs)
# Return the first (oldest) snapshot in the filesystem $fs
###########################################################
sub first_snapshot($) {
	my($fs) = shift;
	my(@snaps) = list_snapshots($fs);
	foreach ( sort @snaps ) {
		return($_);
	}
	return(undef);
}

############################################################
# last_snapshot($)
# Return the latest (newest) snapshot in the filesystem $fs
############################################################
sub last_snapshot($) {
	my($fs) = shift;
	my(@snaps) = list_snapshots($fs);
	my($snap) = undef;
	foreach ( sort @snaps ) {
		$snap = $_;
	}
	return($snap);
}

#######################################################################
# create_snapshot($fs)
# Creates and return the name of a new snapshot in the filesystem $fs
# The snapshot name is created as $fs/<timestamp>.snap
# <timestamp> is the result from timestamp()
# if $fs is "tank/mirror", teh result could be as
# tank/mirror@20150612132704.snap
# This function also creates a logfile $fs/.snaplog which is included
# in the snapshot. Should be used for monitoring.
#######################################################################
sub create_snapshot($) {
	my($fs) = shift;
	my($name) = timestamp();
	my($snap) = "$fs\@$name.snap";
	my($rc);
	my($mountp) = zfs_get($fs,"mountpoint");
	if ( $mountp ) {
		my($snaplog) = $mountp . "/.snaplog";
		unlink($snaplog);
		if ( open(SNAPLOG,">$snaplog") ) {
			my($t) = time;
			my($h) = hostname;
			my($str) = "";
			$str .= "fs=$fs\n";
			$str .= "snap=$snap\n";
			$str .= "host=$h\n";
			$str .= "prog=$prog\n";
			$str .= "version=$version\n";
			$str .= "epoch=$t\n";
			$str .= "date=" . scalar localtime($t) . "\n";
			foreach ( list_snapshots($fs) ) {
				$str .= "snapshots=$_\n";
			}
			$str .= "snapshots=$snap\n";
			print SNAPLOG $str;
			close(SNAPLOG);
		}
		else {
			print "Could not write to $snaplog: $!\n";
		}
	}
	$rc = my_system($zfscommand,"snapshot",$snap);
	if ( $rc ) {
		print "Could not make snapshot $snap, rc=$rc\n";
		return(undef);
	}
	else {
		return($snap);
	}
}

############################################################
# transfer($file))
# Starts the transfer from destdir to transdir
############################################################
sub transfer($) {
	my($file) = shift;
	my($src);
	my($transfered) = 0;
	my($rc);
	
	my(@files) = <$file.*>;
	foreach $src ( sort { $a gt $b } @files ) {
		next unless ( -f $src );
		my($bytes) = undef;
		$bytes = (stat($src))[7]; # size
		next unless ( defined($bytes) );

		my($dst) = $transdir . "/" . basename($src);
		$rc = move($src,$dst);
		if ( $rc ) {
			print "$dst (Ok)\n";
			$transfered += $bytes;
			if ( $maxtransfer > 0 && $transfered > $maxtransfer ) {
				my($waiting) = time;
				while ( -r $dst ) {
					my($diff) = time - $waiting;
					print "Waiting for $dst to be removed...Waited($diff secs) since " . localtime($waiting) . "\n";
					sleep(60);
				}
				$transfered = 0;
			}
		}
		else {
			print "$dst ($!)\n";
		}
	}
	return(0);
}


############################################################
#                                                          #
#       #     #  #    #   #####   #     #     #     ###### #
#      ##   ##  #   #   #     #  ##    #    # #    #     # #
#     # # # #  #  #    #        # #   #   #   #   #     #  #
#    #  #  #  ###      #####   #  #  #  #     #  ######    #
#   #     #  #  #          #  #   # #  #######  #          #
#  #     #  #   #   #     #  #    ##  #     #  #           #
# #     #  #    #   #####   #     #  #     #  #            #
#                                                          #
############################################################
#
# creats, checks and exports a zfs filesystem snapshot into
#  some files, ready to put on a diod and  processed by
#  the rdsnap() function
#
############################################################

sub mksnap($) {
	my($fs) = shift;
	exit(1) unless ( if_fs($fs) );

	my($rc);
	my($snap) = undef;
	my($file) = undef;
	my($last_snap) = last_snapshot($fs);
	

	###################
	# Create snapshot #
	###################
	unless ( $snap ) {
		$snap = create_snapshot($fs);
		unless ( $snap ) {
			exit(1);
		}
		print "Created snapshot $snap\n" if ( $verbose );
	}

	$file = $snap; 
	$file =~ s/\W/./g; # Convert snapname to good filename

	my($config) = "";
	$config .= "fs=$fs\n";
	$config .= "snap=$snap\n";
	$config .= "host=" . hostname . "\n";
	$config .= "prog=$prog\n";
	$config .= "version=$version\n";
	$config .= "epoch=" . time . "\n";
	$config .= "started=" . scalar localtime(time) . "\n";

	my($startfile) = create_done($destdir,$fs,"start",$file);
	#################################
	# Save delta snapshot to a file #
	#################################
	if ( $last_snap ) {
		#
		# Prev snapshots exists
		# Send delta
		#
		my($cmd) = "$zfscommand send -RDev -I $last_snap $snap > $destdir/$file";
		$config .= "lastsnap=$last_snap\n";
		$config .= "zfscmd=$cmd\n";
		$rc = my_system($cmd);
	}
	else {
		#
		# No prev snapshots exists
		# Send filesystem
		#
		my($cmd) = "$zfscommand send -RDev $snap > $destdir/$file";
		$config .= "zfscmd=$cmd\n";
		$rc = my_system($cmd);
	}

	########################################
	# Change directory to output directory #
	########################################
	unless ( chdir($destdir) ) {
		die "chdir($destdir): $!\n" or exit(1);
	}


	#######################################################
	# Compress or move snapshot ( depends on --compress ) #
	#######################################################
	my($ext) = ".comp";
	if ( $compress ) {
		$config .= "compress=1\n";
		$rc = my_system("xz --verbose --compress --force -1 --suffix=$ext $file"); 
		die "Something went wrong when compressing(xz) the snapshot($file), rc=$rc\n" if ( $rc );
	}
	else {
		$config .= "compress=0\n";
		$rc = move($file,$file . $ext);
		die "Something went wrong when moving the snapshot($file), rc=$rc\n" unless ( $rc );
	}

	$file = $file . $ext; # The filename of the commpressed output


	###########################################
	# Checksum the snapshot file before split #
	###########################################
	print "Creating a sha256sum file of the snapshot ($file). This might take some time\n";
	$rc = my_system("sha256sum --binary $file > $file.asc.tot"); 
	die "Something went wrong when checksumming(sha256sum) the file(s): $file\n" if ( $rc );

	##################
	# Split snapshot #
	##################
	if ( $splitbytes ) {
		$config .= "splitbytes=$splitbytes\n";
		$rc = my_system("split --verbose --suffix-length=4 --bytes=$splitbytes --numeric-suffixes $file $file.part."); 
		die "Something went wrong when splitting(split) the compressed snapshot($file), rc=$rc\n" if ( $rc );
	}
	else {
		$config .= "splitbytes=0\n";
		$rc = move($file,$file . ".part.0000");
		die "Something went wrong when moving the snapshot($file), rc=$rc\n" unless ( $rc );
	}


	###########################################################
	# Checksum the resulting files from split and other files #
	###########################################################
	my($partfile);
	unlink("$file.asc");
	foreach $partfile ( <$file.part.*> ) {
		$config .= "$partfile=1\n";
		print "Creating a sha256sum file of the splitfile ($partfile)\n";
		$rc = my_system("sha256sum --binary $partfile >> $file.asc"); 
		die "Something went wrong when checksumming(sha256sum) the file(s): $file.part.*\n" if ( $rc );
	}

	$config .= "ended=" . scalar localtime(time) . "\n";
	###########################
	# Create a config/logfile #
	###########################
	my($configfile) = $file . ".conf";
	unlink($configfile);
	unless ( open(CONF,">$configfile") ) {
		die "Writing to $configfile: $!\n" or exit(1);
	}
	print CONF $config;
	close(CONF);

	$rc = my_system("sha256sum --binary $configfile $file.asc $file.asc.tot > $file.asc.asc"); 
	die "Something went wrong when checksumming(sha256sum) the file(s): $file.asc.tot\n" if ( $rc );

	########################
	# Remove snapshot file #
	########################
	if ( -r $file ) { # Could be moved if splitbytes=0 (above)
		unless ( unlink($file) ) {
			die "unlink($file): $!\n" or exit(1);
		}
	}

	############################################
	# Transfer files from $dstdir to $transdir #
	############################################
	transfer($file);
	unlink($startfile);
	return(0);
}

#############################################################
#                                                           #
#       ######   ######    #####   #     #     #     ###### #
#      #     #  #     #  #     #  ##    #    # #    #     # #
#     #     #  #     #  #        # #   #   #   #   #     #  #
#    ######   #     #   #####   #  #  #  #     #  ######    #
#   #   #    #     #        #  #   # #  #######  #          #
#  #    #   #     #  #     #  #    ##  #     #  #           #
# #     #  ######    #####   #     #  #     #  #            #
#                                                           #
#############################################################
#
# Reads, checks and inserts a filesystem snapshot into
#  a zfs filesystem.
#
#############################################################

sub rdsnap($) {
	my($fs) = shift;
	my($rc);

	die "Usage: $0 <zfs filesystem>\n" unless ( $fs );

	#
	# Locate master snapshot info *.snap.comp.asc.asc file
	# and check its checksum ...
	#

	my($asc1);
	my($file) = $fs; 
	$file =~ s/\W/./g; # Convert snapname to good filename
	print "file=$file\n" if ( $verbose );
	chdir($srcdir);
	foreach $asc1 ( <$file.*.snap.comp.asc.asc> ) {

		#
		# Check checksum on .asc.asc 
		# This file contains
		#<filesystem>.<timestamp>.snap.asc / checksums of all .part files
		#<filesystem>.<timestamp>.snap.asc.tot / checksum of the snap
		#
		print "asc1=$asc1\n" if ( $verbose );
		$rc = my_system("sha256sum --check $asc1"); 
		if ( $rc ) {
			die "Checksum error, exiting...\n" or exit(1);
		}


		my($asc2) = $asc1;
		$asc2 =~ s/\.asc$//;
		print "asc2=$asc2\n" if ( $verbose );
		$rc = my_system("sha256sum --check $asc2"); 
		if ( $rc ) {
			die "Checksum error, exiting...\n" or exit(1);
		}

		#
		# Checksum on .asc is ok
		#
		my($snap) = $asc2;
		$snap =~ s/\.asc$//;
		unlink($snap);

		#
		# Concatenate all files into $snap
		# (Reading filenames from asc file)
		#
		my(@files);
		unless ( open(RES,"<$asc2") ) {
			die "Reading $asc2: $!\n" or exit(1);
		}
		foreach ( <RES> ) {
			next unless ( m/$file/ );
			if ( m/($file.*.part.*)/ ) {
				my($part) = $1;
				push(@files,$part);
			}
		}
		close(RES);

		foreach ( @files ) {
			$rc = my_system("cat $_ >> $snap");
			print "Concatenated $_ to $snap\n";
			if ( $rc ) {
				unlink($snap);
				die "Error concatenating to $snap, exiting...\n" or exit(1);
			}
		}

		my($asc3) = $asc2 . ".tot";
		print "asc3=$asc3\n" if ( $verbose );
		$rc = my_system("sha256sum --check $asc3"); 
		if ( $rc ) {
			unlink($snap);
			die "Checksum error, exiting...\n" or exit(1);
		}


		#################################################
		# Read the machine created (mksnap) config file #
		#################################################
		my($configfile) = $snap . ".conf";
		my(%conf) = ();
		if ( open(CONF,"<$configfile") ) {
			foreach ( <CONF>) {
				chomp;
				my($var,$value) = split(/=/,$_);
				next unless ( $var );
				next unless ( defined($value) );
				print "config:$var\t$value\n";
				$conf{$var}=$value;
			}
		}
		close(CONF);

		#
		# Decompress using xz
		#
		my($ext) = ".comp";
		my($compressed) = $conf{compress};
		#my($compressed) = 0;
		#if ( open(POPEN,"$filecommand $snap |") ) {
		#	foreach ( <POPEN> ) {
		#		$compressed++ if ( m/compressed/ ) ;
		#		print "compressed=$compressed, $_";
		#	}
		#	close(POPEN);
		#}
		#else {
		#	die "Could not verify filetype on $snap: $!\n";
		#}

		if ( $compressed ) {
			$rc = my_system("xz --verbose --decompress --suffix=$ext $snap");
			die "Something went wrong when decompressing(xz) the file $snap, rc=$rc, exiting...\n" if ( $rc );
		}
		else {
			my($newname) = $snap;
			$newname =~ s/$ext$//;
			$rc = move($snap,$newname);
		}
		$snap =~ s/$ext$//;


		#
		# All files are ok
		# Remove checklsum and part files, leaving only the snapshot
		#
		push(@files,$asc1,$asc2,$asc3,$configfile);
		foreach ( @files ) {
			$rc = unlink($_);
			print "unlink($_): $rc\n" if ( $verbose );
		}
	}

	#
	# Insert all snapshots into filesystem
	#
	my($snap);
	my($done) = 0;
	foreach $snap ( <$file.*.snap> ) {
		print "snap=$snap\n" if ( $verbose );
		my($cmd) = "$zfscommand receive ";
		if ( $force ) {
			$cmd .= "-F ";
		}
		$cmd .= "$fs < $snap";
		
		my($rc);
		$rc = my_system($cmd);
		if ( $rc ) {
			die "Could not receive snapshot $snap into $fs, rc=$rc\n" or exit(1);
		}
		else {
			print "$snap is inserted into $fs correctly\n";
			unlink($snap);
		}
		$done++;
	}

	#
	# Set the new? filesystem to be readonly
	#
	if ( $done ) {
		zfs_set($fs,"readonly","on");
	}
	else {
		print "No files found for $fs, check $srcdir directory\n";
	}

	return(0);
}

#############################################
# syncto($snapshot))
# Removes all snapshots newer then $snapshot
#############################################
sub syncto($) {
	my($snapshot) = shift;
	unless ( $snapshot ) {
		die "undefined parameter snapshot in syncto, exiting...\n";
	}

	unless ( if_fs($snapshot) ) {
		die "no filesystem named $snapshot, exiting...\n";
	}
	
	my($fs) = split(/@/,$snapshot);
	unless ( $fs ) {
		die "$snapshot is not a snapshot, exiting...\n";
	}
	my(@snaps) = ();
	my($delsnap) = 0;
	foreach ( list_snapshots($fs) ) {
		if ( $delsnap ) {
			push(@snaps,$_);
			print "Snapshot: $_ (to be deleted)\n";
		}
		elsif ( $_ eq $snapshot ) {
			$delsnap=1;
			print "Snapshot: $_ ***\n";
		}
		else {
			print "Snapshot: $_\n";
		}
	}

	print "\n";
	my($snap);
	my($answer) = 1;
	foreach $snap ( reverse(@snaps) ) {
		unless ( $force ) {
			$answer = ask_for_yes("Destroy snapshot $snap");
		}
		if ( $answer ) {
			print "Destroying snapshot...$snap\n";
			destroy_snapshot($snap);
		}
		else {
			die "Not deleting any snapshot today, exiting...\n";
		}
	}
	exit(0);
}

sub ask_for_yes($) {
	my($prompt) = shift;
	if ( $prompt ) {
		chomp($prompt);
	}
	else {
		$prompt = "";
	}

	my($answer) = undef;
	print $prompt . " (y/n) : ";
	$answer = <STDIN>;
	die "No input" unless ( $answer );
	return( $answer =~ /^y$/i );
}

#############################################
# clean($keep,$fs))
# Removes all old snapshots, keeping only
# $keep newest snapshots.
#############################################
sub clean($$) {
	my($keep) = shift;
	unless ( defined($keep) ) {
		die "undefined parameter keep in clean, exiting...\n";
	}
	my($fs) = shift;
	unless ( $fs ) {
		die "undefined parameter fs in clean, exiting...\n";
	}

	unless ( if_fs($fs) ) {
		die "no filesystem named $fs, exiting...\n";
	}
	
	my(@snaps) = ();
	my(@keepsnaps) = ();
	my($delsnap) = 1;
	my(@allsnaps) = list_snapshots($fs);
	while( $keep-- > 0 ) {
		my($snap) = pop(@allsnaps);
		push(@keepsnaps,$snap);
	}
	foreach ( @allsnaps ) {
		print "Removing snapshot: $_ ***\n";
	}

	foreach ( reverse @keepsnaps ) {
		print "Keeping snapshot:  $_\n";
	}

	print "\n";
	my($snap);
	my($answer) = 1;
	foreach $snap ( @allsnaps )  {
		unless ( $force ) {
			$answer = ask_for_yes("Destroy snapshot $snap");
		}
		if ( $answer ) {
			print "Destroying snapshot...$snap\n";
			destroy_snapshot($snap);
		}
		else {
			die "Not deleting any snapshot today, exiting...\n";
		}
	}
	exit(0);
}

#############################################
# syncfrom($snapshot))
# Removes all snapshots older then $snapshot
#############################################
sub syncfrom($) {
	my($snapshot) = shift;
	unless ( $snapshot ) {
		die "undefined parameter snapshot in syncto, exiting...\n";
	}

	unless ( if_fs($snapshot) ) {
		die "no filesystem named $snapshot, exiting...\n";
	}
	
	my($fs) = split(/@/,$snapshot);
	unless ( $fs ) {
		die "$snapshot is not a snapshot, exiting...\n";
	}
	my(@snaps) = ();
	my($delsnap) = 1;
	foreach ( list_snapshots($fs) ) {
		if ( $_ eq $snapshot ) {
			$delsnap=0;
			print "Snapshot: $_ ***\n";
		}
		elsif ( $delsnap ) {
			push(@snaps,$_);
			print "Snapshot: $_ (to be deleted)\n";
		}
		else {
			print "Snapshot: $_\n";
		}
	}

	print "\n";
	my($snap);
	my($answer) = 1;
	foreach $snap ( reverse(@snaps) ) {
		unless ( $force ) {
			$answer = ask_for_yes("Destroy snapshot $snap");
		}
		if ( $answer ) {
			print "Destroying snapshot...$snap\n";
			destroy_snapshot($snap);
		}
		else {
			die "Not deleting any snapshot today, exiting...\n";
		}
	}
	exit(0);
}

###############################################################################
###############################################################################
###############################################################################

########################################
#                                      #
#       #     #     #     ###  #     # #
#      ##   ##    # #     #   ##    #  #
#     # # # #   #   #    #   # #   #   #
#    #  #  #  #     #   #   #  #  #    #
#   #     #  #######   #   #   # #     #
#  #     #  #     #   #   #    ##      #
# #     #  #     #  ###  #     #       #
#                                      #
########################################
my $result;
my $mksnap = undef;
my $rdsnap = undef;
my $help = undef;
my $clean = undef;
my $fs = undef;
my $restart = undef;
my $syncto = undef;
my $syncfrom = undef;
my $config = $0 . ".conf";

$result = GetOptions (
		"mksnap" => \$mksnap,
		"rdsnap" => \$rdsnap,
		"help" => \$help,
		"fs=s" => \$fs,
		"verbose"  => \$verbose,
		"restart"  => \$restart,
		"force"  => \$force,
		"config=s"  => \$config,
		"syncto=s"  => \$syncto,
		"syncfrom=s"  => \$syncfrom,
		"clean=i"  => \$clean,
		"compress"  => \$compress,
);

my($err) = 0;
if ( $syncto ) {
	exit(syncto($syncto));
}
elsif ( $syncfrom ) {
	exit(syncfrom($syncfrom));
}

$err++ unless ( $fs );
$err++ if ( $help );


my(%conf) = readconf($config);

# Check if mksnap or rdsnap is defined
unless ( $mksnap ) {
	my($tmp) = $conf{mksnap};
	$mksnap = 1 if ( $tmp && $tmp =~ /true/i );
}
unless ( $rdsnap ) {
	my($tmp) = $conf{rdsnap};
	$rdsnap = 1 if ( $tmp && $tmp =~ /true/i );
}

unless ( defined($clean) ) {
	$err++ unless ( $mksnap || $rdsnap );
}

if ( $err ) {
	my($str) = "\n";
	$str .= "Casual usage:\n";
	$str .= "$0 --fs=<zfs filesystem>\n";
	$str .= "\n";
	$str .= "Other arguments:\n";
	$str .= "--mksnap\n\tThe is used on the sending side, but preferbly used in the configuration file: mksnap=true\n";
	$str .= "--rdsnap\n\tThe is used on the receiving side, but preferbly used in the configuration file: rdsnap=true\n";
	$str .= "--config=<config file>\n\tUse an alternative configuration file, default is $0.conf\n";
	$str .= "--compress\n\tCompress all data using xz\n";
	$str .= "--restart\n\tTry to restart the sending process\n";
	$str .= "--help\n\tThis help...\n";
	$str .= "--force\n\tAdds -F to the zfs receive command, be carful...\n";
	$str .= "\t--force also removes snapshots without asking when using --syncto/--syncfrom/--clean, be ware...\n";
	$str .= "--verbose\n\tBe (even) more verbose...\n";
	$str .= "\n";
	$str .= "Housekeeping stuff:\n";
	$str .= "--clean=<number>\n\tKeep the <number> newest snapshots of the selected file system, destroy the rest\n";
	$str .= "\t i.e zsnap.pl --fs=tank/myfs --clean=10, will keep the 10 newest snapshots and destroys the rest\n";
	$str .= "--syncto=<zfs snapshot>\n\tDestroys all snapshot newer then <zfs snapshot>\n";
	$str .= "--syncfrom=<zfs snapshot>\n\tDestroys all snapshot older then <zfs snapshot>\n";
	$str .= "\n";
	$str .= "Both --syncto/--syncfrom/--clean are interactive, i.e you will be asked before removing any snapshots\n";
	$str .= "\tUnless used with the --force argument\n";
	$str .= "\n";
	$str .= "Version: $version\n";

	die($str) or exit(1);
}


# Check if zfscommand is in the config
if ( $conf{zfscommand} ) {
	$zfscommand = check_conf_exec("zfscommand", $conf{zfscommand});
}
# Check if filecommand is in the config
if ( $conf{filecommand} ) {
	$filecommand = check_conf_exec("filecommand", $conf{filecommand});
}
# Check if lockdir is in the config
if ( $conf{lockdir} ) {
	$lockdir = check_conf_dir("lockdir", $conf{lockdir});
}

unless ( mylock($fs) ) {
	die "Could not create lock, exiting...\n" or exit(1);
}

my($rc) = 0;

if ( defined($clean) ) {
	exit(clean($clean,$fs));
}

if ( $mksnap ) {

	# Check if maxtransfer is in the config
	if ( defined($conf{maxtransfer}) ) {
		$maxtransfer = check_conf_dec("maxtransfer",$conf{maxtransfer});
	}
	# Check if splitbytes is in the config
	if ( defined($conf{splitbytes}) ) {
		$splitbytes = check_conf_dec("splitbytes",$conf{splitbytes});
	}

	$destdir = $conf{destdir};
	die "destdir is not defined in $config\n" unless ( $destdir );
	$destdir = check_conf_dir("destdir",$destdir);

	$transdir = $conf{transdir};
	die "transdir is not defined in $config\n" unless ( $transdir );
	$transdir = check_conf_dir("transdir",$transdir);

	#################################################################
	# This section tries to restart a broken transfer, and the exits
	#################################################################
	my($startfile) = done($destdir,$fs,"start");
	if ( defined($startfile) ) {
		if ( $restart ) { # try to restart the transfer
			if ( open(IN,"<$startfile")  ) {
				my($file);
				$file = <IN>;
				close(IN);
				chomp($file);
				$file = $destdir . "/" . $file;
				print "Trying to restart transfer for the snapshot $file\n";
				transfer($file);
				unlink($startfile);
				create_done($transdir,$fs,"done");
				exit(0);
			}
			else {
				die "Reading $startfile: $!\n";
			}
		}
		else {
			die "Thare all already a transfer in progress, $startfile exists...try with --restart\n";
		}
	}

	my($df) = done($transdir,$fs,"done");
	if ( defined($df) ) {
		die "There are already files waiting to be transferd($df), exiting...\n" or exit(1);
	}
	$rc = mksnap($fs);
	create_done($transdir,$fs,"done");
}
elsif ( $rdsnap ) {
	$srcdir = $conf{srcdir};
	die "srcdir is not defined in $config\n" unless ( $srcdir );
	$srcdir = check_conf_dir("srcdir",$srcdir);
	
	my($df) = done($srcdir,$fs,"done");
	unless ( defined($df) ) {
		die "Cant find the transfered files in $srcdir, exiting...\n" or exit(1);
	}
	$rc = rdsnap($fs);
	unlink($df);
}
else {
	print "This should not happend...exiting\n";
	$rc = 42;
}

mylock();
exit($rc);

###############################################################################
###############################################################################
###############################################################################
